const [preventExitTransition, setPreventExitTransition] = useState(false);
	const drag = useRef<DraggableToast>({
		start: 0,
		x: 0,
		y: 0,
		delta: 0,
		removalDistance: 0,
		canCloseOnClick: true,
		canDrag: false,
		boundingRect: null,
		didMove: false,
	}).current;
	function onDragStart(
		e:
			| React.MouseEvent<HTMLElement, MouseEvent>
			| React.TouchEvent<HTMLElement>
	) {
		if (props.isDraggable) {
			// required for ios safari to prevent default swipe behavior
			if (e.nativeEvent.type === "touchstart")
				e.nativeEvent.preventDefault();

			bindDragEvents();
			const toast = props.nodeRef.current!;
			drag.canCloseOnClick = true;
			drag.canDrag = true;
			drag.boundingRect = toast.getBoundingClientRect();
			toast.style.transition = "";
			drag.x = getX(e.nativeEvent as DragEvent);
			drag.y = getY(e.nativeEvent as DragEvent);

			if (props.draggableDirection === DragDirection.X) {
				drag.start = drag.x;
				drag.removalDistance =
					toast.offsetWidth * (props.draggableThreshold / 100);
			} else {
				drag.start = drag.y;
				drag.removalDistance =
					toast.offsetHeight * (props.draggableThreshold / 100);
			}
		}
	}
	function onDragTransitionEnd(
		e:
			| React.MouseEvent<HTMLElement, MouseEvent>
			| React.TouchEvent<HTMLElement>
	) {
		if (drag.boundingRect) {
			const { top, bottom, left, right } = drag.boundingRect;

			if (
				e.nativeEvent.type !== "touchend" &&
				props.isPauseOnHover &&
				drag.x >= left &&
				drag.x <= right &&
				drag.y >= top &&
				drag.y <= bottom
			) {
				// pauseToast();
			} else {
				// playToast();
			}
		}
	}
	function bindDragEvents() {
		drag.didMove = false;
		document.addEventListener("mousemove", onDragMove);
		document.addEventListener("mouseup", onDragEnd);

		document.addEventListener("touchmove", onDragMove);
		document.addEventListener("touchend", onDragEnd);
	}

	function unbindDragEvents() {
		document.removeEventListener("mousemove", onDragMove);
		document.removeEventListener("mouseup", onDragEnd);

		document.removeEventListener("touchmove", onDragMove);
		document.removeEventListener("touchend", onDragEnd);
	}
	function onDragMove(e: MouseEvent | TouchEvent) {
		const toast = props.nodeRef.current!;
		if (drag.canDrag && toast) {
			drag.didMove = true;
			//   if (isRunning) pauseToast();
			drag.x = getX(e as DragEvent);
			drag.y = getY(e as DragEvent);
			if (props.draggableDirection === DragDirection.X) {
				drag.delta = drag.x - drag.start;
			} else {
				drag.delta = drag.y - drag.start;
			}

			// prevent false positif during a toast click
			if (drag.start !== drag.x) drag.canCloseOnClick = false;
			toast.style.transform = `translate${props.draggableDirection}(${drag.delta}px)`;
			toast.style.opacity = `${
				1 - Math.abs(drag.delta / drag.removalDistance)
			}`;
		}
	}

	function onDragEnd() {
		unbindDragEvents();
		const toast = props.nodeRef.current!;
		if (drag.canDrag && drag.didMove && toast) {
			drag.canDrag = false;
			if (Math.abs(drag.delta) > drag.removalDistance) {
				setPreventExitTransition(true);
				props.onClose();
				return;
			}
			toast.style.transition = "transform 0.2s, opacity 0.2s";
			toast.style.transform = `translate${props.draggableDirection}(0)`;
			toast.style.opacity = "1";
		}
	}
	const eventHandlers: DOMAttributes<HTMLElement> = {
		onMouseDown: onDragStart,
		onTouchStart: onDragStart,
		onMouseUp: onDragTransitionEnd,
		onTouchEnd: onDragTransitionEnd,
	};
	return { eventHandlers };